<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <!--
(c) 2024 Scot Watson  All Rights Reserved
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    -->
    <title>Message Test</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noindex, nofollow">
    <style>
@keyframes loading {
  from: { opacity: 0 }
  to: { opacity: 1 }
}
    </style>
    <!-- window-init.js must be loaded classically to ensure capture of page load events -->
    <script id="Init" src="https://scotwatson.github.io/WebInterface/window-init.js"></script>
    <!-- MessageQueue.js must be loaded classically to ensure capture of page load events -->
    <script id="MessageQueue" src="https://scotwatson.github.io/WebInterface/MessageQueue.js"></script>
    <script>
const Init = document.getElementById("Init").exports;
const MessageQueue = document.getElementById("MessageQueue").exports.default;
Init.createQueues(MessageQueue);
const serviceWorkerUrl = new URL("./sw.js", Init.selfUrl);
const serviceWorkerScope = new URL("./", Init.selfUrl);
//IIFE to prevent polluting the global namespace
(() => {
  const pathSegments = Init.selfUrl.pathname.split("/");
  if (pathSegments.length !== 0) {
    pathSegments[pathSegments.length - 1] = "";
  }
  const scopeURI = Init.selfUrl.origin + pathSegments.join("/");
  (async () => {
    function getRequestedVersion() {
      const version = Init.selfUrl.searchParams.get("version");
      Init.selfUrl.searchParams.delete("version")
      window.history.replaceState(Init.selfUrl);
      return version;
    }
    async function getStoredVersion() {
      const SiteStorage = (await import("https://scotwatson.github.io/WebInterface/SiteStorage.mjs")).default;
      const scopedSessionStorage = new SiteStorage({
        uri: scopeURI,
        storage: window.sessionStorage,
      });
      return window.scopedSessionStorage.get("version");
    }
    async function getLatestVersion() {
      async function installServiceWorker(ServiceWorkers) {
        const newestWorker = await (async () => {
          const installing = ServiceWorkers.getInstalling();
          if (installing) { return installing; }
          const waiting = ServiceWorkers.getWaiting();
          if (waiting) { return waiting; }
          const active = ServiceWorkers.getActive();
          if (active) { return active; }
          return await ServiceWorkers.installNew({
            url: serviceWorkerUrl,
            scope: serviceWorkerScope,
          });
        });
        await (async () => {
          if (newestWorker.state === "activated") {
            return;
          }
          const noFail = (async () => {
            function throwOnRedundant(evt) {
              switch (newestWorker.state) {
                case "redundant":
                  newestWorker.removeEventListener("statechange", throwOnRedundant);
                  throw Error("Newest Service Worker failed to load.");
                  break;
                case "activated":
                  newestWorker.removeEventListener("statechange", throwOnRedundant);
                  break;
              }
            }
            newestWorker.addEventListener("statechange", throwOnRedundant);
          })();
          await Promise.race([ noFail, self.navigator.serviceWorker.ready ]);
        })();
        return ServiceWorkers;
      }
      const [ ServiceWorkers, Streams, RPCNode ] = await Promise.all([
        import("https://scotwatson.github.io/WebInterface/service-workers.mjs").then(installServiceWorker),
        import("https://scotwatson.github.io/WebInterface/streams.mjs"),
        import("https://scotwatson.github.io/WebInterface/RPCNode.mjs").then((x) => { return x.default; }),
      ]);
      const controllerRPCNode = new RPCNode({});
      new Streams.Pipe(ServiceWorkers.controllerSource, controllerRPCNode.input);
      new Streams.Pipe(controllerRPCNode.output, ServiceWorkers.controllerSink);
      return await controllerRPCNode.call({
        verb: "getVersion",
        args: {}
      });
    }
    try {
      const [ requestedVersion, storedVersion, latestVersion ] = await Promise.all([ getRequestedVersion, getStoredVersion, getLatestVersion ]);
      const version = (() => {
        if (requestedVersion) { return requestedVersion; }
        if (storedVersion) { return storedVersion; }
        return latestVersion;
      })();
      const versionBaseUrl = new URL("./" + version, Init.selfUrl);
      await import("https://scotwatson.github.io/WebInterface/resources.mjs").then(async (Resources) => {
        Resources.addStyleSheet(new URL("./style.css", versionBaseUrl)),
        Resources.addShortcutIcon(new URL("./favicon.ico", Init.selfUrl)),
        Resources.addIcon(new URL("./favicon.ico", Init.selfUrl)),
        await Promise.all([
          Resources.addScript({
            url: new URL("./index.js", versionBaseUrl),
            defer: true,
            asModule: true,
          }).loading,
        ]);
      });
    } catch (e) {
      console.error(e);
      document.getElementById("appLoading").style.display = "none";
      document.getElementById("appError").style.display = "block";
    }
  })();
})();
    </script>
  </head>
  <body>
    <p id="appLoading" style="font-size:24pt;animation loading 1s">Loading app ...</p>
    <p id="appError" style="display:none">This app encountered an error and cannot run.</p>
  </body>
</html>
